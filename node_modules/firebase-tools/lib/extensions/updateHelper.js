"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inferUpdateSource = exports.updateFromRegistryFile = exports.updateToVersionFromRegistryFile = exports.updateFromPublisherSource = exports.updateToVersionFromPublisherSource = exports.updateFromUrlSource = exports.updateFromLocalSource = exports.update = exports.retryUpdate = exports.displayChanges = exports.warningUpdateToOtherSource = exports.getExistingSourceOrigin = void 0;
const clc = require("cli-color");
const semver = require("semver");
const error_1 = require("../error");
const logger_1 = require("../logger");
const resolveSource = require("./resolveSource");
const extensionsApi = require("./extensionsApi");
const prompt_1 = require("../prompt");
const marked = require("marked");
const extensionsHelper_1 = require("./extensionsHelper");
const utils = require("../utils");
const displayExtensionInfo_1 = require("./displayExtensionInfo");
function invalidSourceErrMsgTemplate(instanceId, source) {
    return `Unable to update from the source \`${clc.bold(source)}\`. To update this instance, you can either:\n
  - Run \`${clc.bold("firebase ext:update " + instanceId)}\` to update from the published source.\n
  - Check your directory path or URL, then run \`${clc.bold("firebase ext:update " + instanceId + " <otherSource>")}\` to update from a local directory or URL source.`;
}
async function getExistingSourceOrigin(projectId, instanceId, extensionName, existingSource) {
    const instance = await extensionsApi.getInstance(projectId, instanceId);
    if (instance && instance.config.extensionRef) {
        return extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION;
    }
    let existingSourceOrigin;
    try {
        const registryEntry = await resolveSource.resolveRegistryEntry(extensionName);
        if (resolveSource.isOfficialSource(registryEntry, existingSource)) {
            existingSourceOrigin = extensionsHelper_1.SourceOrigin.OFFICIAL_EXTENSION;
        }
        else {
            existingSourceOrigin = extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION;
        }
    }
    catch (_a) {
        if (extensionsHelper_1.urlRegex.test(existingSource)) {
            existingSourceOrigin = extensionsHelper_1.SourceOrigin.URL;
        }
        else {
            existingSourceOrigin = extensionsHelper_1.SourceOrigin.LOCAL;
        }
    }
    return existingSourceOrigin;
}
exports.getExistingSourceOrigin = getExistingSourceOrigin;
async function showUpdateVersionInfo(instanceId, from, to, source) {
    if (source) {
        source = clc.bold(source);
    }
    else {
        source = "version";
    }
    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `Updating ${clc.bold(instanceId)} from version ${clc.bold(from)} to ${source} (${clc.bold(to)})`);
    if (semver.lt(to, from)) {
        utils.logLabeledBullet(extensionsHelper_1.logPrefix, "The version you are updating to is less than the current version for this extension. This extension may not be backwards compatible.");
        return await displayExtensionInfo_1.getConsent("version", "Do you wish to continue?");
    }
    return;
}
async function warningUpdateToOtherSource(sourceOrigin) {
    let targetText;
    if ([
        extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION,
        extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION_VERSION,
        extensionsHelper_1.SourceOrigin.OFFICIAL_EXTENSION,
        extensionsHelper_1.SourceOrigin.OFFICIAL_EXTENSION_VERSION,
    ].includes(sourceOrigin)) {
        targetText = "published extension";
    }
    else if (sourceOrigin === extensionsHelper_1.SourceOrigin.LOCAL) {
        targetText = "local directory";
    }
    else if (sourceOrigin === extensionsHelper_1.SourceOrigin.URL) {
        targetText = "URL";
    }
    const warning = `All the instance's resources and logic will be overwritten to use the source code and files from the ${targetText}.\n`;
    logger_1.logger.info(marked(warning));
    const continueUpdate = await prompt_1.promptOnce({
        type: "confirm",
        message: "Do you wish to continue with this update?",
        default: false,
    });
    if (!continueUpdate) {
        throw new error_1.FirebaseError(`Update cancelled.`, { exit: 2 });
    }
}
exports.warningUpdateToOtherSource = warningUpdateToOtherSource;
async function displayChanges(spec, newSpec, isOfficial = true) {
    logger_1.logger.info("This update contains the following changes (in green and red). " +
        "If at any point you choose not to continue, the extension will not be updated and the changes will be discarded:\n");
    displayExtensionInfo_1.displayUpdateChangesNoInput(spec, newSpec, isOfficial);
    await displayExtensionInfo_1.displayUpdateChangesRequiringConfirmation(spec, newSpec);
}
exports.displayChanges = displayChanges;
async function retryUpdate() {
    return prompt_1.promptOnce({
        type: "confirm",
        message: "Are you sure you wish to continue with updating anyways?",
        default: false,
    });
}
exports.retryUpdate = retryUpdate;
async function update(updateOptions) {
    const { projectId, instanceId, source, extRef, params } = updateOptions;
    if (extRef) {
        return await extensionsApi.updateInstanceFromRegistry(projectId, instanceId, extRef, params);
    }
    else if (source) {
        return await extensionsApi.updateInstance(projectId, instanceId, source, params);
    }
    throw new error_1.FirebaseError(`Neither a source nor a version of the extension was supplied for ${instanceId}. Please make sure this is a valid extension and try again.`);
}
exports.update = update;
async function updateFromLocalSource(projectId, instanceId, localSource, existingSpec, existingSource) {
    displayExtensionInfo_1.displayExtInfo(instanceId, "", existingSpec, false);
    let source;
    try {
        source = await extensionsHelper_1.createSourceFromLocation(projectId, localSource);
    }
    catch (err) {
        throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, localSource));
    }
    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold("You are updating this extension instance to a local source.")}`);
    await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, localSource);
    await warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.LOCAL);
    return source.name;
}
exports.updateFromLocalSource = updateFromLocalSource;
async function updateFromUrlSource(projectId, instanceId, urlSource, existingSpec, existingSource) {
    displayExtensionInfo_1.displayExtInfo(instanceId, "", existingSpec, false);
    let source;
    try {
        source = await extensionsHelper_1.createSourceFromLocation(projectId, urlSource);
    }
    catch (err) {
        throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, urlSource));
    }
    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold("You are updating this extension instance to a URL source.")}`);
    await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, urlSource);
    await warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.URL);
    return source.name;
}
exports.updateFromUrlSource = updateFromUrlSource;
async function updateToVersionFromPublisherSource(projectId, instanceId, extVersionRef, existingSpec, existingSource) {
    let source;
    const refObj = extensionsApi.parseRef(extVersionRef);
    const version = refObj.version;
    displayExtensionInfo_1.displayExtInfo(instanceId, refObj.publisherId, existingSpec, true);
    const extension = await extensionsApi.getExtension(`${refObj.publisherId}/${refObj.extensionId}`);
    try {
        source = await extensionsApi.getExtensionVersion(extVersionRef);
    }
    catch (err) {
        throw new error_1.FirebaseError(`Could not find source '${clc.bold(extVersionRef)}' because (${clc.bold(version)}) is not a published version. To update, use the latest version of this extension (${clc.bold(extension.latestVersion)}).`);
    }
    let registryEntry;
    let sourceOrigin;
    try {
        registryEntry = await resolveSource.resolveRegistryEntry(existingSpec.name);
        sourceOrigin =
            registryEntry.publisher === refObj.publisherId
                ? extensionsHelper_1.SourceOrigin.OFFICIAL_EXTENSION
                : extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION;
    }
    catch (err) {
        sourceOrigin = extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION;
    }
    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(`You are updating this extension instance to a(n) ${sourceOrigin}.`)}`);
    if (registryEntry) {
        const minVer = resolveSource.getMinRequiredVersion(registryEntry);
        if (minVer && semver.gt(minVer, source.spec.version)) {
            throw new error_1.FirebaseError(`The version you are trying to update to (${clc.bold(source.spec.version)}) is less than the minimum version required (${clc.bold(minVer)}) to use this extension.`);
        }
    }
    await showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, extVersionRef);
    await warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION);
    if (registryEntry) {
        await resolveSource.promptForUpdateWarnings(registryEntry, existingSpec.version, source.spec.version);
    }
    return source.name;
}
exports.updateToVersionFromPublisherSource = updateToVersionFromPublisherSource;
async function updateFromPublisherSource(projectId, instanceId, extRef, existingSpec, existingSource) {
    return updateToVersionFromPublisherSource(projectId, instanceId, `${extRef}@latest`, existingSpec, existingSource);
}
exports.updateFromPublisherSource = updateFromPublisherSource;
async function updateToVersionFromRegistryFile(projectId, instanceId, existingSpec, existingSource, version) {
    if (version !== "latest" && !semver.valid(version)) {
        throw new error_1.FirebaseError(`cannot update to invalid version ${version}`);
    }
    let registryEntry;
    try {
        registryEntry = await resolveSource.resolveRegistryEntry(existingSpec.name);
    }
    catch (err) {
        throw new error_1.FirebaseError(`Cannot find the latest version of this extension. To update this instance to a local source or URL source, run "firebase ext:update ${instanceId} <localSourceOrURL>".`);
    }
    displayExtensionInfo_1.displayExtInfo(instanceId, registryEntry.publisher, existingSpec, true);
    utils.logLabeledBullet(extensionsHelper_1.logPrefix, clc.bold("You are updating this extension instance to an official source."));
    const minVer = resolveSource.getMinRequiredVersion(registryEntry);
    if (minVer) {
        if (version !== "latest" && semver.gt(minVer, version)) {
            throw new error_1.FirebaseError(`The version you are trying to upgrade to (${clc.bold(version)}) is less than the minimum version required (${clc.bold(minVer)}) to use this extension.`);
        }
    }
    const targetVersion = resolveSource.getTargetVersion(registryEntry, version);
    await showUpdateVersionInfo(instanceId, existingSpec.version, targetVersion);
    await warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.OFFICIAL_EXTENSION);
    await resolveSource.promptForUpdateWarnings(registryEntry, existingSpec.version, targetVersion);
    return resolveSource.resolveSourceUrl(registryEntry, existingSpec.name, targetVersion);
}
exports.updateToVersionFromRegistryFile = updateToVersionFromRegistryFile;
async function updateFromRegistryFile(projectId, instanceId, existingSpec, existingSource) {
    return updateToVersionFromRegistryFile(projectId, instanceId, existingSpec, existingSource, "latest");
}
exports.updateFromRegistryFile = updateFromRegistryFile;
function inferUpdateSource(updateSource, existingRef) {
    if (!updateSource) {
        return `${existingRef}@latest`;
    }
    if (semver.valid(updateSource)) {
        return `${existingRef}@${updateSource}`;
    }
    if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && updateSource.split("/").length < 2) {
        return updateSource.includes("@")
            ? `firebase/${updateSource}`
            : `firebase/${updateSource}@latest`;
    }
    if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && !updateSource.includes("@")) {
        return `${updateSource}@latest`;
    }
    return updateSource;
}
exports.inferUpdateSource = inferUpdateSource;
