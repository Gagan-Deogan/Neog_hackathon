"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageRulesRuntime = exports.StorageRulesIssues = exports.StorageRulesetInstance = void 0;
const cross_spawn_1 = require("cross-spawn");
const error_1 = require("../../../error");
const types_1 = require("./types");
const jwt = require("jsonwebtoken");
const emulatorLogger_1 = require("../../emulatorLogger");
const types_2 = require("../../types");
const metadata_1 = require("../metadata");
const utils = require("../../../utils");
const constants_1 = require("../../constants");
const download_1 = require("../../download");
const fs = require("fs-extra");
const downloadableEmulators_1 = require("../../downloadableEmulators");
class StorageRulesetInstance {
    constructor(runtime, rulesVersion, rulesetName) {
        this.runtime = runtime;
        this.rulesVersion = rulesVersion;
        this.rulesetName = rulesetName;
    }
    async verify(opts, runtimeVariableOverrides = {}) {
        if (opts.method == types_1.RulesetOperationMethod.LIST && this.rulesVersion < 2) {
            const issues = new StorageRulesIssues();
            issues.warnings.push("Permission denied. List operations are only allowed for rules_version='2'.");
            return {
                permitted: false,
                issues,
            };
        }
        return this.runtime.verifyWithRuleset(this.rulesetName, opts, runtimeVariableOverrides);
    }
    unload() {
        throw new Error("NOT_IMPLEMENTED");
    }
}
exports.StorageRulesetInstance = StorageRulesetInstance;
class StorageRulesIssues {
    constructor(errors = [], warnings = []) {
        this.errors = errors;
        this.warnings = warnings;
    }
    static fromResponse(resp) {
        return new StorageRulesIssues(resp.errors || [], resp.warnings || []);
    }
    get all() {
        return [...this.errors, ...this.warnings];
    }
    exist() {
        return !!(this.errors.length || this.warnings.length);
    }
}
exports.StorageRulesIssues = StorageRulesIssues;
class StorageRulesRuntime {
    constructor(_jarPath) {
        this._jarPath = _jarPath;
        this._rulesetCount = 0;
        this._requestCount = 0;
        this._requests = {};
        this._alive = false;
    }
    get alive() {
        return this._alive;
    }
    async start(auto_download = true) {
        const hasEmulator = fs.existsSync(this._jarPath);
        const downloadDetails = downloadableEmulators_1.DownloadDetails[types_2.Emulators.STORAGE];
        if (!hasEmulator) {
            if (auto_download) {
                if (process.env.CI) {
                    utils.logWarning(`It appears you are running in a CI environment. You can avoid downloading the ${constants_1.Constants.description(types_2.Emulators.STORAGE)} repeatedly by caching the ${downloadDetails.opts.cacheDir} directory.`);
                }
                await download_1.downloadEmulator(types_2.Emulators.STORAGE);
            }
            else {
                utils.logWarning("Setup required, please run: firebase setup:emulators:storage");
                throw new error_1.FirebaseError("emulator not found");
            }
        }
        this._alive = true;
        this._childprocess = cross_spawn_1.spawn("java", ["-jar", this._jarPath, "serve"], {
            stdio: ["pipe", "pipe", "pipe"],
        });
        this._childprocess.on("exit", (code) => {
            this._alive = false;
            if (code !== 130) {
                throw new error_1.FirebaseError("Storage Emulator Rules runtime exited unexpectedly.");
            }
        });
        const startPromise = new Promise((resolve) => {
            this._requests[-1] = {
                handler: resolve,
                request: {
                    action: "",
                    id: -1,
                },
            };
        });
        this._childprocess.stderr.on("data", (buf) => {
            const error = buf.toString();
            if (error.includes("Invalid or corrupt jarfile")) {
                throw new error_1.FirebaseError("There was an issue starting the rules emulator, please run 'firebase setup:emulators:storage` again");
            }
            else {
                emulatorLogger_1.EmulatorLogger.forEmulator(types_2.Emulators.STORAGE).log("WARN", `Unexpected rules runtime output: ${buf.toString()}`);
            }
        });
        this._childprocess.stdout.on("data", (buf) => {
            const serializedRuntimeActionResponse = buf.toString("UTF8").trim();
            if (serializedRuntimeActionResponse != "") {
                let rap;
                try {
                    rap = JSON.parse(serializedRuntimeActionResponse);
                }
                catch (err) {
                    emulatorLogger_1.EmulatorLogger.forEmulator(types_2.Emulators.STORAGE).log("INFO", serializedRuntimeActionResponse);
                    return;
                }
                const request = this._requests[rap.id];
                if (rap.status !== "ok") {
                    console.warn(`[RULES] ${rap.status}: ${rap.message}`);
                    rap.errors.forEach(console.warn.bind(console));
                    return;
                }
                if (request) {
                    request.handler(rap);
                }
                else {
                    console.log(`No handler for event ${serializedRuntimeActionResponse}`);
                }
            }
        });
        return startPromise;
    }
    stop() {
        var _a;
        (_a = this._childprocess) === null || _a === void 0 ? void 0 : _a.kill("SIGINT");
    }
    async _sendRequest(rab) {
        if (!this._childprocess) {
            throw new error_1.FirebaseError("Attempted to send Cloud Storage rules request before child was ready");
        }
        const runtimeActionRequest = Object.assign(Object.assign({}, rab), { id: this._requestCount++ });
        if (this._requests[runtimeActionRequest.id]) {
            throw new error_1.FirebaseError("Attempted to send Cloud Storage rules request with stale id");
        }
        return new Promise((resolve) => {
            var _a;
            this._requests[runtimeActionRequest.id] = {
                request: runtimeActionRequest,
                handler: resolve,
            };
            const serializedRequest = JSON.stringify(runtimeActionRequest);
            (_a = this._childprocess) === null || _a === void 0 ? void 0 : _a.stdin.write(serializedRequest + "\n");
        });
    }
    async loadRuleset(source) {
        const runtimeActionRequest = {
            action: "load_ruleset",
            context: {
                rulesetName: (this._rulesetCount++).toString(),
                source,
            },
        };
        const response = (await this._sendRequest(runtimeActionRequest));
        if (response.errors.length || response.warnings.length) {
            return {
                issues: StorageRulesIssues.fromResponse(response),
            };
        }
        else {
            return {
                issues: StorageRulesIssues.fromResponse(response),
                ruleset: new StorageRulesetInstance(this, response.result.rulesVersion, runtimeActionRequest.context.rulesetName),
            };
        }
    }
    async verifyWithRuleset(rulesetName, opts, runtimeVariableOverrides = {}) {
        if (!opts.path.startsWith("/")) {
            opts.path = `/${opts.path}`;
        }
        if (opts.path.endsWith("/")) {
            opts.path = opts.path.slice(0, -1);
        }
        const runtimeVariables = Object.assign({ resource: toExpressionValue(opts.file.before || null), request: createRequestExpressionValue(opts) }, runtimeVariableOverrides);
        const runtimeActionRequest = {
            action: "verify",
            context: {
                rulesetName: rulesetName,
                service: "firebase.storage",
                path: opts.path,
                method: opts.method,
                variables: runtimeVariables,
            },
        };
        const response = (await this._sendRequest(runtimeActionRequest));
        if (!response.errors)
            response.errors = [];
        if (!response.warnings)
            response.warnings = [];
        if (response.errors.length) {
            return {
                issues: StorageRulesIssues.fromResponse(response),
            };
        }
        else {
            return {
                issues: StorageRulesIssues.fromResponse(response),
                permitted: response.result.permit,
            };
        }
    }
}
exports.StorageRulesRuntime = StorageRulesRuntime;
function toExpressionValue(obj) {
    if (typeof obj == "string") {
        return { string_value: obj };
    }
    if (typeof obj == "number") {
        if (Math.floor(obj) == obj) {
            return { int_value: obj };
        }
        else {
            return { float_value: obj };
        }
    }
    if (obj instanceof Date) {
        return {
            timestamp_value: metadata_1.toSerializedDate(obj),
        };
    }
    if (Array.isArray(obj)) {
        return {
            list_value: {
                values: obj.map(toExpressionValue),
            },
        };
    }
    if (obj instanceof Set) {
        return {
            set_value: {
                values: [...obj].map(toExpressionValue),
            },
        };
    }
    if (obj == null) {
        return {
            null_value: 0,
        };
    }
    if (typeof obj == "object") {
        const fields = {};
        Object.keys(obj).forEach((key) => {
            fields[key] = toExpressionValue(obj[key]);
        });
        return {
            map_value: {
                fields,
            },
        };
    }
    console.warn(obj);
    throw new error_1.FirebaseError(`Can not convert variables for Cloud Storage rules runtime`);
}
function createAuthExpressionValue(opts) {
    if (!opts.token) {
        return toExpressionValue(null);
    }
    else {
        const tokenPayload = jwt.decode(opts.token);
        const jsonValue = {
            uid: tokenPayload.user_id,
            token: tokenPayload,
        };
        return toExpressionValue(jsonValue);
    }
}
function createRequestExpressionValue(opts) {
    const fields = {
        path: {
            path_value: {
                segments: opts.path
                    .split("/")
                    .filter((s) => s)
                    .slice(3)
                    .map((simple) => ({
                    simple,
                })),
            },
        },
        time: toExpressionValue(new Date()),
        resource: toExpressionValue(opts.file.after ? opts.file.after : null),
        auth: opts.token ? createAuthExpressionValue(opts) : { null_value: 0 },
    };
    return {
        map_value: {
            fields,
        },
    };
}
