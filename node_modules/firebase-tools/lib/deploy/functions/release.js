"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.release = void 0;
const clc = require("cli-color");
const utils = require("../../utils");
const helper = require("../../functionsDeployHelper");
const deploymentPlanner_1 = require("./deploymentPlanner");
const tasks = require("./tasks");
const functionsConfig_1 = require("../../functionsConfig");
const prompts_1 = require("./prompts");
const queue_1 = require("../../throttler/queue");
const deploymentTimer_1 = require("./deploymentTimer");
const errorHandler_1 = require("./errorHandler");
async function release(context, options, payload) {
    if (!options.config.has("functions")) {
        return;
    }
    const projectId = context.projectId;
    const sourceUrl = context.uploadUrl;
    const appEngineLocation = functionsConfig_1.getAppEngineLocation(context.firebaseConfig);
    const timer = new deploymentTimer_1.DeploymentTimer();
    const errorHandler = new errorHandler_1.ErrorHandler();
    const fullDeployment = deploymentPlanner_1.createDeploymentPlan(payload.functions.byRegion, context.existingFunctions, context.filters);
    const cloudFunctionsQueue = new queue_1.default({
        retries: 30,
        backoff: 20000,
        concurrency: 40,
        maxBackoff: 40000,
        handler: tasks.functionsDeploymentHandler(timer, errorHandler),
    });
    const schedulerQueue = new queue_1.default({
        handler: tasks.schedulerDeploymentHandler(errorHandler),
    });
    const regionPromises = [];
    const taskParams = {
        projectId,
        sourceUrl,
        runtime: context.runtimeChoice,
        errorHandler,
    };
    const shouldDeleteFunctions = await prompts_1.promptForFunctionDeletion(fullDeployment.functionsToDelete, options.force, options.nonInteractive);
    if (shouldDeleteFunctions) {
        for (const fnName of fullDeployment.functionsToDelete) {
            const task = tasks.deleteFunctionTask(taskParams, fnName);
            cloudFunctionsQueue.run(task);
        }
    }
    else {
        fullDeployment.schedulesToDelete = fullDeployment.schedulesToDelete.filter((fnName) => {
            return !fullDeployment.functionsToDelete.includes(fnName);
        });
        if (fullDeployment.functionsToDelete.length !== 0) {
            utils.logBullet(clc.bold.cyan("functions: ") + "continuing with other deployments.");
        }
    }
    for (const regionalDeployment of fullDeployment.regionalDeployments) {
        regionPromises.push(tasks.runRegionalFunctionDeployment(taskParams, regionalDeployment, cloudFunctionsQueue));
        for (const fn of regionalDeployment.schedulesToUpsert) {
            const task = tasks.upsertScheduleTask(taskParams, fn, appEngineLocation);
            schedulerQueue.run(task);
        }
    }
    for (const fnName of fullDeployment.schedulesToDelete) {
        const task = tasks.deleteScheduleTask(taskParams, fnName, appEngineLocation);
        schedulerQueue.run(task);
    }
    const queuePromises = [cloudFunctionsQueue.wait(), schedulerQueue.wait()];
    cloudFunctionsQueue.process();
    schedulerQueue.process();
    schedulerQueue.close();
    await Promise.all(regionPromises);
    cloudFunctionsQueue.close();
    try {
        await Promise.all(queuePromises);
    }
    catch (err) {
        utils.reject("Exceeded maximum retries while deploying functions. " +
            "If you are deploying a large number of functions, " +
            "please deploy your functions in batches by using the --only flag, " +
            "and wait a few minutes before deploying again. " +
            "Go to https://firebase.google.com/docs/cli/#partial_deploys to learn more.", {
            original: err,
        });
    }
    helper.logAndTrackDeployStats(cloudFunctionsQueue, errorHandler);
    helper.printTriggerUrls(projectId, sourceUrl);
    errorHandler.printWarnings();
    errorHandler.printErrors();
}
exports.release = release;
