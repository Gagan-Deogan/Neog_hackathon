"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schedulerDeploymentHandler = exports.deleteScheduleTask = exports.upsertScheduleTask = exports.runRegionalFunctionDeployment = exports.functionsDeploymentHandler = exports.deleteFunctionTask = exports.updateFunctionTask = exports.createFunctionTask = void 0;
const clc = require("cli-color");
const logger_1 = require("../../logger");
const utils = require("../../utils");
const gcp_1 = require("../../gcp");
const deploymentTool = require("../../deploymentTool");
const helper = require("../../functionsDeployHelper");
const operation_poller_1 = require("../../operation-poller");
const api_1 = require("../../api");
const parseRuntimeAndValidateSDK_1 = require("../../parseRuntimeAndValidateSDK");
const pubsub_1 = require("../../gcp/pubsub");
const defaultPollerOptions = {
    apiOrigin: api_1.functionsOrigin,
    apiVersion: gcp_1.cloudfunctions.API_VERSION,
    masterTimeout: 25 * 60000,
};
function createFunctionTask(params, fn, sourceToken, onPoll) {
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "creating " +
            parseRuntimeAndValidateSDK_1.getHumanFriendlyRuntimeName(params.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn.name)) +
            "...");
        const eventType = fn.eventTrigger ? fn.eventTrigger.eventType : "https";
        const createRes = await gcp_1.cloudfunctions.createFunction({
            projectId: params.projectId,
            region: helper.getRegion(fn.name),
            eventType: eventType,
            functionName: helper.getFunctionId(fn.name),
            entryPoint: fn.entryPoint,
            trigger: helper.getFunctionTrigger(fn),
            labels: Object.assign({}, deploymentTool.labels(), fn.labels),
            sourceUploadUrl: params.sourceUrl,
            sourceToken: sourceToken,
            runtime: params.runtime,
            availableMemoryMb: fn.availableMemoryMb,
            timeout: fn.timeout,
            maxInstances: fn.maxInstances,
            environmentVariables: fn.environmentVariables,
            vpcConnector: fn.vpcConnector,
            vpcConnectorEgressSettings: fn.vpcConnectorEgressSettings,
            serviceAccountEmail: fn.serviceAccountEmail,
            ingressSettings: fn.ingressSettings,
        });
        const pollerOptions = Object.assign({
            pollerName: `create-${fn.name}`,
            operationResourceName: createRes.name,
            onPoll,
        }, defaultPollerOptions);
        const operationResult = await operation_poller_1.pollOperation(pollerOptions);
        if (eventType === "https") {
            try {
                await gcp_1.cloudfunctions.setIamPolicy({
                    name: fn.name,
                    policy: gcp_1.cloudfunctions.DEFAULT_PUBLIC_POLICY,
                });
            }
            catch (err) {
                params.errorHandler.record("warning", fn.name, "make public", err.original.message);
            }
        }
        return operationResult;
    };
    return {
        run,
        functionName: fn.name,
        operationType: "create",
    };
}
exports.createFunctionTask = createFunctionTask;
function updateFunctionTask(params, fn, sourceToken, onPoll) {
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "updating " +
            parseRuntimeAndValidateSDK_1.getHumanFriendlyRuntimeName(params.runtime) +
            " function " +
            clc.bold(helper.getFunctionLabel(fn.name)) +
            "...");
        const eventType = fn.eventTrigger ? fn.eventTrigger.eventType : "https";
        const updateRes = await gcp_1.cloudfunctions.updateFunction({
            projectId: params.projectId,
            region: helper.getRegion(fn.name),
            eventType: eventType,
            functionName: helper.getFunctionId(fn.name),
            entryPoint: fn.entryPoint,
            trigger: helper.getFunctionTrigger(fn),
            labels: Object.assign({}, deploymentTool.labels(), fn.labels),
            sourceUploadUrl: params.sourceUrl,
            sourceToken: sourceToken,
            runtime: params.runtime,
            availableMemoryMb: fn.availableMemoryMb,
            timeout: fn.timeout,
            maxInstances: fn.maxInstances,
            environmentVariables: fn.environmentVariables,
            vpcConnector: fn.vpcConnector,
            vpcConnectorEgressSettings: fn.vpcConnectorEgressSettings,
            serviceAccountEmail: fn.serviceAccountEmail,
            ingressSettings: fn.ingressSettings,
        });
        const pollerOptions = Object.assign({
            pollerName: `update-${fn.name}`,
            operationResourceName: updateRes.name,
            onPoll,
        }, defaultPollerOptions);
        const operationResult = await operation_poller_1.pollOperation(pollerOptions);
        return operationResult;
    };
    return {
        run,
        functionName: fn.name,
        operationType: "update",
    };
}
exports.updateFunctionTask = updateFunctionTask;
function deleteFunctionTask(params, fnName) {
    const run = async () => {
        utils.logBullet(clc.bold.cyan("functions: ") +
            "deleting function " +
            clc.bold(helper.getFunctionLabel(fnName)) +
            "...");
        const deleteRes = await gcp_1.cloudfunctions.deleteFunction({
            functionName: fnName,
        });
        const pollerOptions = Object.assign({
            pollerName: `delete-${fnName}`,
            operationResourceName: deleteRes.name,
        }, defaultPollerOptions);
        return await operation_poller_1.pollOperation(pollerOptions);
    };
    return {
        run,
        functionName: fnName,
        operationType: "delete",
    };
}
exports.deleteFunctionTask = deleteFunctionTask;
function functionsDeploymentHandler(timer, errorHandler) {
    return async (task) => {
        var _a, _b, _c, _d;
        let result;
        try {
            timer.startTimer(task.functionName, task.operationType);
            result = await task.run();
            helper.printSuccess(task.functionName, task.operationType);
        }
        catch (err) {
            if (((_c = (_b = (_a = err.original) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.response) === null || _c === void 0 ? void 0 : _c.statusCode) === 429) {
                throw err;
            }
            errorHandler.record("error", task.functionName, task.operationType, ((_d = err.original) === null || _d === void 0 ? void 0 : _d.message) || "");
        }
        timer.endTimer(task.functionName);
        return result;
    };
}
exports.functionsDeploymentHandler = functionsDeploymentHandler;
function runRegionalFunctionDeployment(params, regionalDeployment, queue) {
    const onPollFn = (op) => {
        var _a, _b;
        const shouldFinishDeployment = (((_a = op.metadata) === null || _a === void 0 ? void 0 : _a.sourceToken) && !regionalDeployment.sourceToken) ||
            (!((_b = op.metadata) === null || _b === void 0 ? void 0 : _b.sourceToken) && op.done);
        if (shouldFinishDeployment) {
            logger_1.logger.debug(`Got sourceToken ${op.metadata.sourceToken} for region ${regionalDeployment.region}`);
            regionalDeployment.sourceToken = op.metadata.sourceToken;
            finishRegionalFunctionDeployment(params, regionalDeployment, queue);
        }
    };
    if (regionalDeployment.functionsToCreate.length) {
        const firstFn = regionalDeployment.functionsToCreate.shift();
        const task = createFunctionTask(params, firstFn, undefined, onPollFn);
        return queue.run(task);
    }
    else if (regionalDeployment.functionsToUpdate.length) {
        const firstFn = regionalDeployment.functionsToUpdate.shift();
        const task = updateFunctionTask(params, firstFn, undefined, onPollFn);
        return queue.run(task);
    }
    return Promise.resolve();
}
exports.runRegionalFunctionDeployment = runRegionalFunctionDeployment;
function finishRegionalFunctionDeployment(params, regionalDeployment, queue) {
    for (const fn of regionalDeployment.functionsToCreate) {
        queue.run(createFunctionTask(params, fn, regionalDeployment.sourceToken));
    }
    for (const fn of regionalDeployment.functionsToUpdate) {
        queue.run(updateFunctionTask(params, fn, regionalDeployment.sourceToken));
    }
}
function upsertScheduleTask(params, fn, appEngineLocation) {
    const run = async () => {
        const job = helper.toJob(fn, appEngineLocation, params.projectId);
        return await gcp_1.cloudscheduler.createOrReplaceJob(job);
    };
    return {
        run,
        functionName: fn.name,
        operationType: "upsert schedule",
    };
}
exports.upsertScheduleTask = upsertScheduleTask;
function deleteScheduleTask(params, fnName, appEngineLocation) {
    const run = async () => {
        const jobName = helper.getScheduleName(fnName, appEngineLocation);
        const topicName = helper.getTopicName(fnName);
        await gcp_1.cloudscheduler.deleteJob(jobName);
        await pubsub_1.deleteTopic(topicName);
    };
    return {
        run,
        functionName: fnName,
        operationType: "delete schedule",
    };
}
exports.deleteScheduleTask = deleteScheduleTask;
function schedulerDeploymentHandler(errorHandler) {
    return async (task) => {
        let result;
        try {
            result = await task.run();
            helper.printSuccess(task.functionName, task.operationType);
        }
        catch (err) {
            if (err.status === 429) {
                throw err;
            }
            else if (err.status !== 404) {
                errorHandler.record("error", task.functionName, task.operationType, err.message || "");
            }
        }
        return result;
    };
}
exports.schedulerDeploymentHandler = schedulerDeploymentHandler;
